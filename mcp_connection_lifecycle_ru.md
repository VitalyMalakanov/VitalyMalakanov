## 5. Жизненный цикл соединения MCP

Жизненный цикл соединения в Model Context Protocol (MCP) описывает стандартизированную последовательность этапов, через которые проходит взаимодействие между клиентом и сервером, от момента установления связи до ее прекращения. Этот цикл обеспечивает предсказуемость и надежность коммуникации.

### 5.1 Инициализация (Initialization)

Инициализация — это первый и обязательный этап любого MCP-соединения. Он служит для "рукопожатия" (handshake) между клиентом и сервером, в ходе которого они обмениваются информацией о своих возможностях и согласовывают параметры взаимодействия.

Процесс инициализации выглядит следующим образом:

1.  **Запрос `initialize` от клиента к серверу:**
    *   Клиент (например, IDE, десктопное приложение) первым отправляет серверу запрос с методом `initialize`.
    *   В параметрах (`params`) этого запроса клиент передает:
        *   `protocolVersion`: Версия протокола MCP, которую он поддерживает (например, `"1.0"`).
        *   `capabilities`: Объект, детализирующий возможности клиента (например, какие форматы данных он понимает, какие опциональные функции протокола поддерживает).
        *   `clientInfo` (необязательно): Информация о клиенте, такая как имя и версия (например, `{"name": "Visual Studio Code", "version": "1.80.0"}`).
        *   `rootUri` или `workspaceFolders` (необязательно): Информация о корневой директории проекта или рабочих папках, с которыми работает клиент.

2.  **Ответ на `initialize` от сервера клиенту:**
    *   Получив запрос `initialize`, сервер анализирует возможности клиента.
    *   Если сервер может поддержать предложенную версию протокола и базовые требования, он отвечает успешным сообщением-результатом.
    *   Этот ответ содержит:
        *   `serverInfo`: Информация о сервере (имя, версия).
        *   `capabilities`: Объект, описывающий возможности сервера. Это позволяет клиенту узнать, какие методы сервер предоставляет, какие уведомления может отправлять и т.д. Сервер может выбрать подмножество возможностей клиента или предложить свои.

3.  **Уведомление `initialized` от клиента к серверу:**
    *   После того как клиент получил и обработал успешный ответ на `initialize` от сервера, он должен отправить серверу уведомление (notification) с методом `initialized`.
    *   Параметры этого уведомления обычно пустые (`{}`).
    *   Это уведомление сигнализирует серверу, что клиент готов к полноценному обмену сообщениями в соответствии с согласованными возможностями.

4.  **Начало нормального обмена сообщениями:**
    *   После получения сервером уведомления `initialized`, фаза инициализации считается успешно завершенной. Теперь обе стороны могут начать обмениваться другими запросами и уведомлениями, определенными в протоколе и их согласованных возможностях.

### 5.2 Обмен сообщениями (Message Exchange)

Это основная фаза жизненного цикла, во время которой клиент и сервер взаимодействуют для выполнения полезной работы. MCP поддерживает два основных паттерна обмена сообщениями, инициировать которые может любая из сторон:

*   **Запрос-Ответ (Request-Response):**
    *   Одна сторона отправляет другой сообщение-запрос (Request) с определенным методом и параметрами, указывая `id`.
    *   Принимающая сторона обрабатывает запрос и отвечает либо сообщением-результатом (Result) с тем же `id` (в случае успеха), либо сообщением-ошибкой (Error) с тем же `id` (в случае неудачи).
    *   Этот паттерн используется для операций, требующих явного ответа, например, запрос данных, выполнение команды.

*   **Уведомления (Notifications):**
    *   Одна сторона отправляет другой сообщение-уведомление (Notification) с определенным методом и параметрами, но **без** `id`.
    *   Принимающая сторона обрабатывает уведомление, но не отправляет никакого ответа.
    *   Этот паттерн используется для информирования о событиях, не требующих подтверждения, например, изменение состояния, лог-сообщения, прогресс операции.

### 5.3 Завершение (Termination)

Завершение соединения может произойти по нескольким причинам и несколькими способами:

*   **Штатное завершение (Clean Shutdown):**
    Это предпочтительный способ завершения работы, инициируемый обычно клиентом.
    1.  **Клиент отправляет запрос `shutdown` серверу.** Этот запрос просит сервер подготовиться к завершению работы (например, сохранить состояние, освободить ресурсы). `id` присутствует.
    2.  **Сервер отвечает на запрос `shutdown`.** После завершения своих подготовительных операций сервер отправляет клиенту пустой успешный ответ на `shutdown` (с тем же `id`). С этого момента сервер не должен принимать новые запросы, кроме `exit`.
    3.  **Клиент отправляет уведомление `exit` серверу.** После получения ответа на `shutdown`, клиент отправляет уведомление `exit`. Это сигнал серверу, что он должен немедленно завершить свою работу.
    4.  **Сервер, получив `exit`, должен завершить процесс.** Некоторые реализации протокола также могут предусматривать, что сервер *может* отправить уведомление `exit` клиенту перед фактическим завершением, если он инициирует завершение со своей стороны, хотя чаще инициатива на клиенте.
    *   SDK могут абстрагировать этот двухэтапный процесс (трёхэтапный с ответом) в один вызов метода, например, `dispose()` или `close()`.

*   **Отключение транспорта (Transport Disconnection):**
    *   Соединение может быть прервано из-за проблем на транспортном уровне (например, обрыв сетевого соединения для HTTP/SSE, закрытие стандартных потоков ввода/вывода для Stdio, сбой процесса одной из сторон).
    *   Обе стороны должны быть готовы к таким ситуациям и корректно обрабатывать их, пытаясь освободить ресурсы.

*   **Условия ошибки (Error Conditions):**
    *   Критические ошибки протокола (например, невозможность разобрать сообщение, нарушение последовательности сообщений на этапе инициализации) или невосстановимые внутренние ошибки в клиенте или сервере могут привести к принудительному разрыву соединения.

В любом случае завершения, обе стороны должны стремиться к корректному освобождению всех занятых ресурсов.
