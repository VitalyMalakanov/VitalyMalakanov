# Документация по разработке MCP-серверов

## 1. Введение в Model Context Protocol (MCP)

**Model Context Protocol (MCP)** — это открытый стандартный протокол, предназначенный для унификации и упрощения взаимодействия между современными системами искусственного интеллекта (ИИ), особенно большими языковыми моделями (LLM), и разнообразными внешними источниками данных, инструментами и сервисами. В мире, где ИИ все глубже интегрируется в рабочие процессы и приложения, MCP предлагает стандартизированный "язык" общения, позволяющий ИИ-ассистентам безопасно и эффективно получать доступ к необходимому контексту и возможностям.

**Основные цели MCP:**

*   **Упрощение интеграций:** Замена множества частных, зачастую сложных и несовместимых друг с другом интеграций единым, хорошо документированным протоколом. Это снижает сложность разработки и поддержки для создателей ИИ-приложений и провайдеров инструментов.
*   **Повышение релевантности ответов ИИ:** Предоставление ИИ-моделям структурированного доступа к актуальным данным и специализированным инструментам позволяет им генерировать более точные, контекстуально-обоснованные и полезные ответы.
*   **Обеспечение безопасности данных:** Стандартизация протокола включает в себя лучшие практики безопасности, помогая разработчикам создавать более защищенные решения при работе с потенциально чувствительной информацией.

**Ключевые преимущества использования MCP:**

*   **Гибкость в выборе ИИ-провайдеров и инструментов:** Стандартный протокол позволяет легче переключаться между различными ИИ-моделями и интегрировать широкий спектр инструментов от разных поставщиков без необходимости полной переработки интеграционной логики.
*   **Растущий список готовых интеграций:** По мере принятия стандарта сообществом, ожидается рост числа готовых MCP-серверов для популярных источников данных и сервисов, что еще больше ускорит разработку.
*   **Встроенные лучшие практики:** MCP разрабатывается с учетом опыта создания подобных систем и включает рекомендации по безопасности, обработке ошибок и жизненному циклу соединений, способствуя созданию более качественных и надежных приложений.

## 2. Обзор архитектуры MCP

**MCP (Messaging Capabilities Protocol / Протокол Возможностей Обмена Сообщениями)** — это стандартный протокол, разработанный для унификации способа подключения ассистентов искусственного интеллекта (ИИ) и приложений на базе больших языковых моделей (LLM) к разнообразным источникам данных, инструментам и другим функциональным возможностям.

**Цель и задачи MCP:** Ключевая цель MCP — заменить множество фрагментированных, зачастую проприетарных и сложных в поддержке интеграций единым, стандартизированным протоколом. Это позволяет ИИ-ассистентам получать более качественный и релевантный доступ к необходимой информации из различных систем и сервисов. Предоставляя ИИ доступ к актуальным и контекстуально верным данным, MCP способствует генерации более точных, полезных и обоснованных ответов и действий. Вместо того чтобы разработчикам приходилось реализовывать и поддерживать отдельные "коннекторы" для каждого нового источника данных или инструмента, MCP предлагает общий язык и набор правил для такого взаимодействия.

**Общая архитектура клиент-сервер:**

MCP построен на основе классической клиент-серверной модели. В этой модели:

*   **Клиент (Client)** — это программный компонент, который инициирует запросы к серверу для получения данных или вызова определенных функций.
*   **Сервер (Server)** — это программный компонент, который "слушает" запросы от клиентов, обрабатывает их и возвращает ответы, либо предоставляет доступ к своим ресурсам или возможностям.

В контексте MCP данная модель реализуется следующим образом:

*   **Хосты (Hosts):** Это приложения, в которых функционируют или к которым подключаются ИИ-ассистенты или LLM. Хосты выступают инициаторами MCP-соединений. Примерами могут служить десктопные приложения (например, Claude Desktop, специализированные ИИ-клиенты), интегрированные среды разработки (IDE), веб-приложения или серверные системы, использующие LLM. Хост-приложение предоставляет среду для работы MCP Клиента.

*   **MCP Клиенты (MCP Clients):** Это протокольные клиенты, встроенные или используемые хост-приложением. MCP Клиент отвечает за установку, поддержку и управление соединением с MCP Сервером по протоколу MCP. Обычно каждый MCP Клиент поддерживает одно выделенное соединение (1:1) с одним MCP Сервером для доступа к определенному набору возможностей. Он формирует запросы на основе потребностей хост-приложения и обрабатывает ответы/уведомления от сервера.

*   **MCP Серверы (MCP Servers):** Это, как правило, специализированные, легковесные программы или сервисы. Их задача — предоставлять (или "экспонировать") определенные возможности — будь то доступ к данным (файлы, базы данных, API), выполнение инструментов (например, запуск скриптов, компиляция кода) или предоставление наборов промптов (заранее определенных инструкций для LLM) — через стандартный интерфейс MCP. Сервер обрабатывает запросы от MCP Клиента и возвращает результаты.

**Описание диаграммы архитектуры:**

Представьте диаграмму, где центральным элементом является **"Хост-приложение (например, Claude Desktop, IDE)"**. Внутри этого хост-приложения или тесно связанный с ним располагается **"MCP Клиент"**. От "MCP Клиента" исходит линия связи (соединение) к **"MCP Серверу"**. "MCP Сервер", в свою очередь, показан как имеющий доступ к различным нижележащим ресурсам: это могут быть **"Локальные источники данных (например, файловая система, локальные базы данных, конфигурационные файлы)"** и/или **"Удаленные сервисы и инструменты (например, внешние API, корпоративные системы, облачные хранилища, другие утилиты)"**. Стрелки на диаграмме иллюстрируют поток взаимодействия: Хост-приложение через MCP Клиента отправляет запросы MCP Серверу; MCP Сервер, взаимодействуя со своими источниками данных или инструментами, формирует и отправляет ответы обратно MCP Клиенту, который передает их Хост-приложению. Также могут быть показаны уведомления, идущие от сервера к клиенту.

## 3. Основные компоненты MCP-сервера

MCP-сервер (и в равной степени MCP-клиент) для своей работы опирается на два фундаментальных уровня: протокольный и транспортный. Эти уровни разделяют ответственность за логику обмена сообщениями и фактическую передачу данных.

### 3.1 Протокольный уровень (Protocol Layer)

**Роль:** Протокольный уровень является "мозгом" MCP. Он отвечает за:
*   **Фрейминг сообщений (Message Framing):** Определение структуры и границ каждого сообщения в соответствии со стандартом JSON-RPC 2.0.
*   **Связывание запросов и ответов (Request/Response Linking):** Гарантирует, что каждый ответ или ошибка корректно сопоставляется с исходным запросом с помощью уникальных идентификаторов (`id`).
*   **Высокоуровневые шаблоны коммуникации (High-Level Communication Patterns):** Управляет логикой инициализации соединения, обработкой запросов, ответов, уведомлений и процедурой завершения соединения.

**Обработка входящих сообщений:** Когда сообщение поступает с транспортного уровня, протокольный уровень анализирует его. Если это запрос, он направляется соответствующему обработчику (handler), зарегистрированному для данного типа запроса (определяемого полем `method`). Если это уведомление, оно также передается соответствующему обработчику уведомлений. Если это ответ, протокольный уровень связывает его с ожидающим запросом.

**SDK и ключевые абстракции:** Для упрощения разработки приложений, работающих по MCP, предоставляются SDK (Software Development Kits – Наборы для Разработки ПО). Эти SDK предлагают высокоуровневые абстракции, скрывающие детали реализации протокола. Ключевые классы/интерфейсы обычно включают:

*   `Protocol` (или `Connection`, `Session`): Объект, инкапсулирующий состояние и логику всего MCP-соединения. Например, в Python SDK это может быть класс `Session`.
*   `Client`: Представляет клиентскую сторону соединения, предоставляя методы для отправки запросов и уведомлений.
*   `Server`: Представляет серверную сторону, предоставляя механизмы для регистрации обработчиков запросов и уведомлений.

Примеры обобщенных сигнатур методов, которые могут предоставляться SDK (точные имена и параметры зависят от конкретного языка и реализации):

*   Для сервера:
    *   `setRequestHandler(methodName: string, handler: (params: any) => Promise<any> | any)`: Регистрация обработчика для запросов с указанным `methodName`.
    *   `setNotificationHandler(methodName: string, handler: (params: any) => void)`: Регистрация обработчика для уведомлений.
*   Для клиента (или общего объекта `Session`):
    *   `sendRequest(methodName: string, params?: any): Promise<any>`: Отправка запроса и возврат Promise, который разрешится результатом или ошибкой.
    *   `sendNotification(methodName: string, params?: any): void`: Отправка уведомления.

Эти абстракции позволяют разработчикам сосредоточиться на бизнес-логике своих приложений, а не на низкоуровневых деталях протокола.

### 3.2 Транспортный уровень (Transport Layer)

**Роль:** Транспортный уровень отвечает за фактическую двунаправленную передачу байтов (сериализованных сообщений) между MCP-клиентом и MCP-сервером. Он обеспечивает нижележащий канал связи.

**JSON-RPC 2.0 через все транспорты:** Независимо от выбранного транспортного механизма, все сообщения MCP кодируются с использованием **JSON-RPC 2.0**. Это означает, что данные, передаваемые по транспортному каналу, представляют собой строки в формате JSON, структурированные согласно спецификации JSON-RPC 2.0. Подробную информацию о спецификации можно найти здесь: [https://www.jsonrpc.org/specification](https://www.jsonrpc.org/specification).

**Поддерживаемые транспортные механизмы:**

MCP поддерживает несколько транспортных механизмов, чтобы обеспечить гибкость в различных сценариях развертывания:

1.  **Stdio транспорт (Standard Input/Output Transport):**
    *   **Описание:** Использует стандартные потоки ввода (`stdin`) и вывода (`stdout`) процесса для обмена сообщениями. Клиент пишет JSON-RPC сообщения в `stdin` серверного процесса, а сервер пишет свои JSON-RPC сообщения в свой `stdout`, откуда их читает клиент.
    *   **Применение:** Идеально подходит для локального взаимодействия процессов, например, когда хост-приложение (например, IDE) запускает MCP-сервер как дочерний процесс на той же машине.
    *   **Преимущества:** Простота настройки для локальных сценариев, отсутствие необходимости в сетевой конфигурации, низкие задержки.

2.  **HTTP с SSE транспортом (HTTP with Server-Sent Events Transport):**
    *   **Описание:** Этот гибридный транспорт использует:
        *   **HTTP POST запросы:** для сообщений, идущих от клиента к серверу. Каждое JSON-RPC сообщение (запрос или уведомление) отправляется как тело HTTP POST запроса.
        *   **Server-Sent Events (SSE):** для сообщений, идущих от сервера к клиенту. SSE — это стандарт W3C, который позволяет серверу асинхронно отправлять данные клиенту по одному долгоживущему HTTP-соединению. Это эффективно для передачи ответов и уведомлений от сервера.
    *   **Применение:** Подходит для удаленного взаимодействия (клиент и сервер на разных машинах) или в случаях, когда коммуникация должна проходить через стандартную веб-инфраструктуру (например, прокси-серверы, балансировщики нагрузки).
    *   **Преимущества:** Совместимость со стандартной веб-инфраструктурой, хорошая поддержка в браузерах и серверных технологиях, эффективная передача данных от сервера к клиенту в реальном времени.

**Выбор подходящего транспорта:**

*   Для **локальных серверов**, особенно тех, что управляются как дочерние процессы хост-приложения, **Stdio транспорт** является наиболее распространенным и рекомендуемым выбором из-за его простоты и эффективности.
*   Для **удаленных серверов** или когда требуется интеграция через стандартные веб-протоколы, **HTTP с SSE транспортом** предоставляет надежное и широко совместимое решение.

Выбор транспорта определяется архитектурными требованиями приложения, такими как местоположение клиента и сервера, требования к безопасности и существующая инфраструктура.

## 4. Типы сообщений в MCP

Model Context Protocol (MCP) полностью основывается на спецификации **JSON-RPC 2.0** для определения структуры и семантики сообщений, которыми обмениваются клиент и сервер. JSON-RPC 2.0 определяет четыре основных типа сообщений, каждый из которых служит уникальной цели в рамках протокола. Все сообщения являются объектами JSON.

### 1. Запросы (Requests)

**Назначение:** Сообщение-запрос отправляется одной стороной (клиентом или сервером) другой стороне для вызова определенного метода (процедуры) и получения ответа.

**Структура и ключевые поля:**

*   `jsonrpc`: Строка, значение которой **должно быть** точно `"2.0"`.
*   `method`: Строка, содержащая имя вызываемого метода (например, `textDocument/didOpen`, `initialize`, `$/setTrace`). Имена, начинающиеся с `$/`, зарезервированы для системных (predefined) уведомлений и запросов.
*   `params` (необязательное): Объект или массив, содержащий параметры, передаваемые вызываемому методу. Если параметры не нужны, это поле может быть опущено.
*   `id`: Уникальный идентификатор, устанавливаемый отправителем запроса. Может быть строкой, числом или (в редких случаях) `null`. Это поле **обязательно** для запросов, ожидающих ответ. Сервер использует тот же `id` в своем ответе (результате или ошибке), чтобы клиент мог сопоставить ответ с исходным запросом.

**Пример запроса:**

Клиент запрашивает у сервера список доступных ресурсов, фильтруя их по типу "документы".

```json
{
  "jsonrpc": "2.0",
  "method": "listResources",
  "params": { "filter": "documents" },
  "id": "req-001"
}
```

### 2. Ответы на запросы / Результаты (Results)

**Назначение:** Сообщение-ответ (или результат) отправляется получателем запроса в случае его успешного выполнения. Оно содержит результат работы вызванного метода.

**Структура и ключевые поля:**

*   `jsonrpc`: Строка, значение которой **должно быть** точно `"2.0"`.
*   `result`: Поле, содержащее данные, являющиеся результатом выполнения запроса. Значение этого поля может быть любым валидным JSON-типом (объект, массив, строка, число, булево значение, `null`), в зависимости от спецификации метода.
*   `id`: Точно такой же идентификатор, который был указан в поле `id` исходного запроса. Это поле **обязательно**.

**Пример ответа с результатом:**

Сервер успешно обработал запрос `req-001` и возвращает список ресурсов.

```json
{
  "jsonrpc": "2.0",
  "result": [
    { "uri": "file:///home/user/doc1.txt", "name": "Документ 1", "type": "document" },
    { "uri": "file:///home/user/report.docx", "name": "Отчет.docx", "type": "document" }
  ],
  "id": "req-001"
}
```

### 3. Ошибки (Errors)

**Назначение:** Сообщение об ошибке отправляется получателем запроса, если запрос не может быть выполнен или в процессе его выполнения произошла ошибка.

**Структура и ключевые поля:**

*   `jsonrpc`: Строка, значение которой **должно быть** точно `"2.0"`.
*   `error`: Объект, содержащий детализированную информацию об ошибке. Этот объект **обязателен**.
    *   `code`: Целое число, указывающее тип произошедшей ошибки (например, стандартные коды JSON-RPC, такие как `-32601` для "Method not found").
    *   `message`: Строка, предоставляющая краткое описание ошибки.
    *   `data` (необязательное): Дополнительное, специфичное для ошибки, значение. Может содержать более подробную информацию или структурированные данные об ошибке.
*   `id`: Точно такой же идентификатор, который был указан в поле `id` исходного запроса. Если ошибка не может быть ассоциирована с конкретным запросом (например, ошибка разбора JSON, когда `id` не может быть извлечен), это поле **должно быть** `null`.

**Пример сообщения об ошибке:**

Сервер не смог найти метод `listResourcess` (опечатка в имени метода), запрошенный клиентом с `id: "req-002"`.

```json
{
  "jsonrpc": "2.0",
  "error": {
    "code": -32601,
    "message": "Method not found: listResourcess",
    "data": {
      "details": "The method 'listResourcess' does not exist. Did you mean 'listResources'?"
    }
  },
  "id": "req-002"
}
```

### 4. Уведомления (Notifications)

**Назначение:** Уведомления — это сообщения, которые отправляются для информирования другой стороны о каком-либо событии. В отличие от запросов, уведомления **не предполагают ответа**. Это однонаправленная коммуникация. Если при обработке уведомления возникает ошибка, она не отправляется обратно отправителю.

**Структура и ключевые поля:**

*   `jsonrpc`: Строка, значение которой **должно быть** точно `"2.0"`.
*   `method`: Строка, содержащая имя метода уведомления (например, `textDocument/didChange`, `$/initialized`).
*   `params` (необязательное): Объект или массив, содержащий параметры для уведомления.

**Ключевое отличие от запроса:** Поле `id` **ДОЛЖНО ОТСУТСТВОВАТЬ**. Именно отсутствие `id` указывает на то, что сообщение является уведомлением, а не запросом.

**Пример уведомления:**

Сервер уведомляет клиента о том, что он успешно завершил процесс инициализации.

```json
{
  "jsonrpc": "2.0",
  "method": "initialized"
}
```
Другой пример: клиент уведомляет сервер об изменении конфигурации.
```json
{
  "jsonrpc": "2.0",
  "method": "workspace/didChangeConfiguration",
  "params": {
    "settings": {
      "editor.fontSize": 14
    }
  }
}
```

## 5. Жизненный цикл соединения MCP

Жизненный цикл соединения в Model Context Protocol (MCP) описывает стандартизированную последовательность этапов, через которые проходит взаимодействие между клиентом и сервером, от момента установления связи до ее прекращения. Этот цикл обеспечивает предсказуемость и надежность коммуникации.

### 5.1 Инициализация (Initialization)

Инициализация — это первый и обязательный этап любого MCP-соединения. Он служит для "рукопожатия" (handshake) между клиентом и сервером, в ходе которого они обмениваются информацией о своих возможностях и согласовывают параметры взаимодействия.

Процесс инициализации выглядит следующим образом:

1.  **Запрос `initialize` от клиента к серверу:**
    *   Клиент (например, IDE, десктопное приложение) первым отправляет серверу запрос с методом `initialize`.
    *   В параметрах (`params`) этого запроса клиент передает:
        *   `protocolVersion`: Версия протокола MCP, которую он поддерживает (например, `"1.0"`).
        *   `capabilities`: Объект, детализирующий возможности клиента (например, какие форматы данных он понимает, какие опциональные функции протокола поддерживает).
        *   `clientInfo` (необязательно): Информация о клиенте, такая как имя и версия (например, `{"name": "Visual Studio Code", "version": "1.80.0"}`).
        *   `rootUri` или `workspaceFolders` (необязательно): Информация о корневой директории проекта или рабочих папках, с которыми работает клиент.

2.  **Ответ на `initialize` от сервера клиенту:**
    *   Получив запрос `initialize`, сервер анализирует возможности клиента.
    *   Если сервер может поддержать предложенную версию протокола и базовые требования, он отвечает успешным сообщением-результатом.
    *   Этот ответ содержит:
        *   `serverInfo`: Информация о сервере (имя, версия).
        *   `capabilities`: Объект, описывающий возможности сервера. Это позволяет клиенту узнать, какие методы сервер предоставляет, какие уведомления может отправлять и т.д. Сервер может выбрать подмножество возможностей клиента или предложить свои.

3.  **Уведомление `initialized` от клиента к серверу:**
    *   После того как клиент получил и обработал успешный ответ на `initialize` от сервера, он должен отправить серверу уведомление (notification) с методом `initialized`.
    *   Параметры этого уведомления обычно пустые (`{}`).
    *   Это уведомление сигнализирует серверу, что клиент готов к полноценному обмену сообщениями в соответствии с согласованными возможностями.

4.  **Начало нормального обмена сообщениями:**
    *   После получения сервером уведомления `initialized`, фаза инициализации считается успешно завершенной. Теперь обе стороны могут начать обмениваться другими запросами и уведомлениями, определенными в протоколе и их согласованных возможностях.

### 5.2 Обмен сообщениями (Message Exchange)

Это основная фаза жизненного цикла, во время которой клиент и сервер взаимодействуют для выполнения полезной работы. MCP поддерживает два основных паттерна обмена сообщениями, инициировать которые может любая из сторон:

*   **Запрос-Ответ (Request-Response):**
    *   Одна сторона отправляет другой сообщение-запрос (Request) с определенным методом и параметрами, указывая `id`.
    *   Принимающая сторона обрабатывает запрос и отвечает либо сообщением-результатом (Result) с тем же `id` (в случае успеха), либо сообщением-ошибкой (Error) с тем же `id` (в случае неудачи).
    *   Этот паттерн используется для операций, требующих явного ответа, например, запрос данных, выполнение команды.

*   **Уведомления (Notifications):**
    *   Одна сторона отправляет другой сообщение-уведомление (Notification) с определенным методом и параметрами, но **без** `id`.
    *   Принимающая сторона обрабатывает уведомление, но не отправляет никакого ответа.
    *   Этот паттерн используется для информирования о событиях, не требующих подтверждения, например, изменение состояния, лог-сообщения, прогресс операции.

### 5.3 Завершение (Termination)

Завершение соединения может произойти по нескольким причинам и несколькими способами:

*   **Штатное завершение (Clean Shutdown):**
    Это предпочтительный способ завершения работы, инициируемый обычно клиентом.
    1.  **Клиент отправляет запрос `shutdown` серверу.** Этот запрос просит сервер подготовиться к завершению работы (например, сохранить состояние, освободить ресурсы). `id` присутствует.
    2.  **Сервер отвечает на запрос `shutdown`.** После завершения своих подготовительных операций сервер отправляет клиенту пустой успешный ответ на `shutdown` (с тем же `id`). С этого момента сервер не должен принимать новые запросы, кроме `exit`.
    3.  **Клиент отправляет уведомление `exit` серверу.** После получения ответа на `shutdown`, клиент отправляет уведомление `exit`. Это сигнал серверу, что он должен немедленно завершить свою работу.
    4.  **Сервер, получив `exit`, должен завершить процесс.** Некоторые реализации протокола также могут предусматривать, что сервер *может* отправить уведомление `exit` клиенту перед фактическим завершением, если он инициирует завершение со своей стороны, хотя чаще инициатива на клиенте.
    *   SDK могут абстрагировать этот двухэтапный процесс (трёхэтапный с ответом) в один вызов метода, например, `dispose()` или `close()`.

*   **Отключение транспорта (Transport Disconnection):**
    *   Соединение может быть прервано из-за проблем на транспортном уровне (например, обрыв сетевого соединения для HTTP/SSE, закрытие стандартных потоков ввода/вывода для Stdio, сбой процесса одной из сторон).
    *   Обе стороны должны быть готовы к таким ситуациям и корректно обрабатывать их, пытаясь освободить ресурсы.

*   **Условия ошибки (Error Conditions):**
    *   Критические ошибки протокола (например, невозможность разобрать сообщение, нарушение последовательности сообщений на этапе инициализации) или невосстановимые внутренние ошибки в клиенте или сервере могут привести к принудительному разрыву соединения.

В любом случае завершения, обе стороны должны стремиться к корректному освобождению всех занятых ресурсов.

## 6. Обработка ошибок в MCP

Model Context Protocol (MCP) использует стандартный механизм обработки ошибок, определенный в спецификации **JSON-RPC 2.0**. Это обеспечивает унифицированный подход к сообщению о проблемах, возникающих во время взаимодействия между клиентом и сервером.

### Стандартные коды ошибок (Standard Error Codes)

JSON-RPC 2.0 определяет набор стандартных кодов ошибок, которые должны использоваться для обозначения общих проблем протокольного уровня. MCP полностью придерживается этих кодов:

*   **`-32700 ParseError (Ошибка разбора)`:**
    *   **Значение:** Сервер получил некорректно сформированный JSON. Сообщение не удалось разобрать как валидный JSON-документ.
    *   **Пример:** Клиент отправляет строку `{"jsonrpc": "2.0", "method": "foo"` (незакрытая кавычка).

*   **`-32600 InvalidRequest (Некорректный запрос)`:**
    *   **Значение:** Отправленный JSON является валидным, но сам запрос не соответствует спецификации JSON-RPC 2.0.
    *   **Пример:** Отсутствует обязательное поле `jsonrpc: "2.0"` или поле `method`. Запрос является уведомлением, но содержит поле `id`.

*   **`-32601 MethodNotFound (Метод не найден)`:**
    *   **Значение:** Указанный в поле `method` запроса метод не существует или недоступен на сервере.
    *   **Пример:** Клиент вызывает метод `server/nonExistentMethod`.

*   **`-32602 InvalidParams (Некорректные параметры)`:**
    *   **Значение:** Метод существует, но предоставленные параметры (`params`) недействительны или не соответствуют ожиданиям метода (например, неверный тип, отсутствуют обязательные параметры, переданы избыточные параметры, которые метод не может обработать).
    *   **Пример:** Метод ожидает параметр `count` как число, но получает строку: `{"count": "abc"}`.

*   **`-32603 InternalError (Внутренняя ошибка)`:**
    *   **Значение:** Указывает на внутреннюю ошибку на стороне сервера при обработке запроса. Эта ошибка обычно означает проблему в коде самого сервера, не связанную напрямую с корректностью или содержимым запроса.
    *   **Пример:** Необработанное исключение в логике серверного метода, проблема с доступом к базе данных на стороне сервера.

Спецификация JSON-RPC также резервирует диапазон кодов от `-32000` до `-32099` для предопределенных ошибок сервера. **SDK и приложения могут определять собственные пользовательские коды ошибок (custom error codes) со значениями выше -32000.** Это позволяет передавать специфичные для приложения ошибки, которые не покрываются стандартными кодами.

### Структура объекта ошибки (Error Object Structure)

Когда запрос не может быть успешно выполнен, сервер возвращает JSON-RPC ответ, который вместо поля `result` содержит поле `error`. Этот объект `error` имеет следующую стандартизированную структуру:

*   `code`: (Число, Integer) Целочисленный код, который идентифицирует тип ошибки (один из стандартных или пользовательский код).
*   `message`: (Строка, String) Краткое, человекочитаемое описание ошибки. Это сообщение в первую очередь предназначено для разработчиков или для логирования и не всегда подходит для прямого отображения конечным пользователям.
*   `data` (необязательное): (Любой тип, Any) Дополнительное поле, которое может содержать структурированные данные, относящиеся к конкретной ошибке. Содержимое этого поля определяется сервером. Например, для ошибки `InvalidParams` оно может содержать информацию о том, какой именно параметр был неверным.

**Пример объекта ошибки в ответе:**
```json
{
  "jsonrpc": "2.0",
  "error": {
    "code": -32602,
    "message": "Invalid params: 'count' parameter must be an integer.",
    "data": {
      "field": "count",
      "expectedType": "integer",
      "actualType": "string"
    }
  },
  "id": "request-id-789"
}
```

### Распространение ошибок (Error Propagation)

Ошибки в системе, использующей MCP, могут возникать и должны обрабатываться на различных уровнях:

1.  **Через объекты `error` в ответах на запросы:**
    *   Это основной и наиболее явный способ сообщения об ошибках, связанных с обработкой конкретного запроса. Клиент, отправивший запрос, должен всегда проверять, содержит ли ответ поле `result` или `error`.

2.  **Через события ошибок на транспортном уровне:**
    *   Проблемы могут возникнуть на уровне самого транспортного соединения (например, Stdio, HTTP/SSE). Примеры таких проблем:
        *   Разрыв TCP-соединения для HTTP/SSE.
        *   Неожиданное закрытие потоков `stdin`/`stdout` для Stdio.
        *   Ошибки HTTP-протокола (например, код состояния `404 Not Found` если эндпоинт MCP не существует, или `503 Service Unavailable`).
    *   Эти ошибки обычно приводят к полному разрыву MCP-соединения. SDK должны предоставлять механизмы для отслеживания состояния транспортного соединения и уведомления приложения о таких событиях (например, через колбэки `onDisconnected` или события `transportError`).

3.  **Через обработчики ошибок на уровне протокола/SDK:**
    *   SDK могут предоставлять глобальные обработчики ошибок или события для проблем, которые не связаны с конкретным запросом-ответом, но влияют на состояние протокола. Например:
        *   Ошибки десериализации сообщения, которое не является ни запросом, ни ответом, ни уведомлением.
        *   Тайм-ауты ожидания ответа на запрос (если реализованы в SDK).
        *   Проблемы во время фазы инициализации, не покрываемые стандартным ответом-ошибкой на `initialize`.
    *   Эти механизмы позволяют приложению централизованно реагировать на общие проблемы связи или протокола.

Надлежащая стратегия обработки ошибок включает проверку ответов на наличие поля `error`, готовность к неожиданным разрывам соединения и, при необходимости, реализацию логики повторных попыток или информирования пользователя о проблеме.

## 7. Примеры реализации MCP-сервера

В этом разделе представлены базовые примеры реализации MCP-сервера на языках Python и TypeScript, демонстрирующие основные концепции, такие как создание сервера, регистрация обработчиков запросов и подключение транспорта.

### 7.1 Пример на Python

Этот пример показывает простой MCP-сервер на Python, который использует стандартные потоки ввода/вывода (stdio) для связи и предоставляет один ресурс.

```python
import asyncio
import mcp.types as types  # Импорт определений типов MCP
from mcp.server import Server  # Импорт класса Server из SDK
from mcp.server.stdio import stdio_server  # Импорт функции для создания stdio транспорта

# Создание экземпляра сервера с именем "example-server"
app = Server("example-server")

# Регистрация обработчика для запроса 'list_resources'
# Этот метод будет вызван, когда клиент запросит список ресурсов.
@app.list_resources()
async def list_resources() -> list[types.Resource]:
    # Возвращаем список ресурсов
    return [
        types.Resource(
            uri="example://resource",  # URI ресурса
            name="Example Resource"     # Имя ресурса для отображения
        )
    ]

# Основная асинхронная функция для запуска сервера
async def main():
    # Используем stdio_server для получения потоков ввода/вывода
    async with stdio_server() as streams:
        # Запуск сервера с полученными потоками и опциями инициализации
        await app.run(
            streams[0],  # Поток для чтения (stdin)
            streams[1],  # Поток для записи (stdout)
            app.create_initialization_options()  # Создание стандартных опций инициализации
        )

# Точка входа в программу
if __name__ == "__main__":
    asyncio.run(main())  # Запуск асинхронного приложения
```
В данном примере:
1.  Инициализируется `Server` с уникальным именем.
2.  С помощью декоратора `@app.list_resources()` регистрируется асинхронная функция `list_resources`, которая будет обрабатывать запросы на получение списка ресурсов.
3.  Функция `main` настраивает `stdio_server` для коммуникации через стандартные потоки и запускает сервер `app.run()`, передавая ему эти потоки и опции инициализации.

### 7.2 Пример на TypeScript

Этот пример демонстрирует аналогичный MCP-сервер на TypeScript, также использующий stdio транспорт и предоставляющий один ресурс.

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { ListResourcesRequestSchema } from "@modelcontextprotocol/sdk/protocol"; // Предполагаемый импорт схемы запроса ListResources

// Создание экземпляра MCP сервера
// Указываем информацию о сервере (имя, версия) и его возможности.
const server = new Server({
  name: "example-server",       // Имя сервера
  version: "1.0.0"              // Версия сервера
}, {
  capabilities: {               // Определение возможностей сервера
    resources: {}               // Базовая возможность: поддержка ресурсов (детали могут быть расширены)
  }
});

// Регистрация обработчика для запросов типа ListResourcesRequestSchema.
// Этот обработчик будет вызван, когда клиент отправит запрос на получение списка ресурсов.
server.setRequestHandler(ListResourcesRequestSchema, async () => {
  // Возвращаем объект с полем 'resources', содержащим массив ресурсов.
  return {
    resources: [
      {
        uri: "example://resource",  // URI ресурса
        name: "Example Resource"     // Имя ресурса для отображения
      }
    ]
  };
});

// Настройка и подключение транспорта.
// В данном случае используется StdioServerTransport, который работает через стандартные потоки ввода/вывода.
const transport = new StdioServerTransport(); // Создание экземпляра Stdio транспорта
await server.connect(transport);               // Подключение сервера к транспорту для начала обмена сообщениями

console.log("MCP Server (TypeScript) started using Stdio transport."); // Сообщение о запуске сервера
```
В этом TypeScript примере:
1.  Создается экземпляр `Server`, передавая ему информацию о сервере и его возможностях.
2.  Метод `server.setRequestHandler()` используется для привязки обработчика к запросам, соответствующим `ListResourcesRequestSchema`. Обработчик асинхронно возвращает список ресурсов.
3.  Создается `StdioServerTransport`, и сервер подключается к этому транспорту с помощью `server.connect(transport)`.
4.  Добавлено сообщение в консоль для индикации того, что сервер запущен.

Эти примеры служат отправной точкой для создания более сложных MCP-серверов. Разработчики могут добавлять больше обработчиков для различных запросов и уведомлений, а также реализовывать более сложную логику внутри этих обработчиков.

## 8. Лучшие практики и Безопасность

При разработке и внедрении MCP-серверов и клиентов важно придерживаться лучших практик и уделять должное внимание аспектам безопасности. Это обеспечит надежность, производительность и защищенность ваших решений.

### 8.1 Выбор транспорта (Transport Selection)

Правильный выбор транспортного механизма зависит от сценария использования вашего MCP-сервера.

*   **Локальное взаимодействие (Local Interaction):**
    *   **Рекомендация:** Использовать **Stdio (стандартные потоки ввода/вывода)**.
    *   **Преимущества:**
        *   **Эффективность:** Наиболее эффективен для коммуникации между процессами на одной машине, так как не требует сетевого стека.
        *   **Простое управление процессами:** Хост-приложение может легко запускать MCP-сервер как дочерний процесс и управлять его жизненным циклом.
    *   **Пример:** IDE запускает языковой сервер или инструмент анализа кода как MCP-сервер.

*   **Удаленное взаимодействие (Remote Interaction):**
    *   **Рекомендация:** Использовать **HTTP с Server-Sent Events (SSE)**.
    *   **Преимущества:**
        *   **HTTP-совместимость:** Позволяет использовать стандартную веб-инфраструктуру (прокси, балансировщики нагрузки, межсетевые экраны).
        *   **Широкая поддержка:** HTTP и SSE хорошо поддерживаются большинством платформ и языков программирования.
    *   **Аспекты безопасности:**
        *   При удаленном взаимодействии критически важно обеспечить безопасность канала передачи данных (см. раздел "Аспекты безопасности").
        *   Необходимо рассмотреть механизмы **аутентификации** (проверки подлинности клиента/сервера) и **авторизации** (проверки прав доступа к ресурсам).

### 8.2 Обработка сообщений (Message Handling)

Качественная обработка сообщений — залог стабильности и предсказуемости MCP-сервера.

*   **Обработка запросов (Request Handling):**
    *   **Тщательная валидация входных данных:** Всегда проверяйте параметры (`params`), полученные в запросах. Не доверяйте слепо клиентским данным. Убедитесь, что типы данных, их значения и структура соответствуют ожиданиям.
    *   **Использование типобезопасных схем:** Если возможно, используйте схемы (например, JSON Schema) или классы/типы для определения структуры сообщений и их автоматической валидации. Это помогает отлавливать ошибки на ранних этапах.
    *   **Корректная обработка ошибок:** При возникновении ошибок возвращайте стандартизированные JSON-RPC сообщения об ошибках с соответствующими кодами и информативными сообщениями (см. раздел "Управление ошибками").
    *   **Реализация тайм-аутов:** Для длительных операций или при взаимодействии с внешними системами предусматривайте тайм-ауты, чтобы избежать "зависания" сервера или клиента в ожидании ответа.

*   **Отчет о прогрессе (Progress Reporting):**
    *   Для операций, выполнение которых может занять продолжительное время, используйте механизм отчета о прогрессе (если он определен в вашем MCP SDK или расширениях протокола, например, через `$/progress` уведомления, как в LSP). Это позволяет клиенту информировать пользователя о ходе выполнения операции.

*   **Управление ошибками (Error Management):**
    *   **Использование соответствующих кодов ошибок:** Применяйте стандартные коды ошибок JSON-RPC (`-32700` - `-32600`) для общих проблем протокола и определяйте пользовательские коды для специфичных ошибок приложения (выше `-32000`).
    *   **Включение полезных сообщений об ошибках:** Сообщения об ошибках должны быть достаточно информативными для разработчика (для отладки), но при этом не должны раскрывать чувствительную информацию (см. "Безопасная обработка ошибок").

### 8.3 Аспекты безопасности (Security Considerations)

Безопасность является первостепенной задачей, особенно при работе с удаленными соединениями или при доступе к чувствительным данным и операциям.

*   **Безопасность транспорта (Transport Security):**
    *   **Использование TLS:** Для всех удаленных соединений (например, при использовании HTTP/SSE) обязательно используйте шифрование TLS (HTTPS) для защиты данных при передаче от перехвата и модификации.
    *   **Валидация источника соединения:** Проверяйте, от кого исходит соединение. Для HTTPS это может включать проверку клиентских сертификатов (mTLS) или использование токенов аутентификации.
    *   **Реализация аутентификации:** Если сервер предоставляет доступ к приватным данным или операциям, реализуйте надежные механизмы аутентификации (например, API-ключи, OAuth 2.0 токены, передаваемые в заголовках HTTP или через параметры инициализации MCP).

*   **Валидация сообщений (Message Validation):**
    *   **Валидация всех входящих сообщений:** Не только параметров запросов, но и структуры самих JSON-RPC сообщений.
    *   **Санитизация входных данных:** Обрабатывайте входные данные для предотвращения атак типа инъекций (например, если параметры используются для формирования команд ОС или SQL-запросов – хотя такие прямые использования крайне не рекомендуются).
    *   **Проверка ограничений на размер сообщений:** Установите разумные ограничения на максимальный размер входящих сообщений, чтобы предотвратить DoS-атаки через отправку чрезмерно больших запросов.
    *   **Проверка формата JSON-RPC:** Убедитесь, что сообщение соответствует требованиям JSON-RPC 2.0 (наличие `jsonrpc: "2.0"`, корректный `id` для запросов, отсутствие `id` для уведомлений и т.д.).

*   **Защита ресурсов (Resource Protection):**
    *   **Реализация контроля доступа (Авторизация):** После аутентификации проверяйте, имеет ли аутентифицированный пользователь или клиент права на выполнение запрошенной операции или доступ к запрашиваемому ресурсу.
    *   **Валидация путей к ресурсам:** Если сервер работает с файловой системой или другими ресурсами по путям, тщательно валидируйте и нормализуйте пути, чтобы предотвратить атаки типа "Path Traversal" (выход за пределы разрешенной директории). Не используйте пути, напрямую составленные из пользовательского ввода, без строгой проверки.
    *   **Мониторинг использования ресурсов:** Отслеживайте, как используются ресурсы сервера (ЦП, память, сеть, файловые дескрипторы), чтобы выявлять аномальную активность.
    *   **Ограничение частоты запросов (Rate Limiting):** Внедряйте механизмы ограничения частоты запросов от одного клиента, чтобы предотвратить злоупотребления и DoS-атаки.

*   **Безопасная обработка ошибок (Secure Error Handling):**
    *   **Не допускать утечки чувствительной информации:** Сообщения об ошибках, возвращаемые клиенту, не должны содержать внутреннюю информацию о системе, которая может быть использована для атаки (например, стектрейсы, пути к файлам на сервере, SQL-запросы).
    *   **Логирование ошибок, связанных с безопасностью:** Все подозрительные события, попытки несанкционированного доступа или ошибки валидации, связанные с безопасностью, должны подробно логироваться на стороне сервера для последующего анализа.
    *   **Реализация корректной очистки ресурсов:** В случае ошибок или при завершении сессии убедитесь, что все выделенные ресурсы (файлы, соединения, память) корректно освобождаются.
    *   **Учет сценариев DoS-атак:** Продумывайте, как ваш сервер будет справляться с большим количеством запросов, медленными клиентами или запросами, вызывающими ресурсоемкие операции.

### 8.4 Отладка и мониторинг (Debugging and Monitoring)

Эффективные средства отладки и мониторинга упрощают разработку, поддержку и диагностику проблем.

*   **Логирование (Logging):**
    *   **Логирование событий протокола:** Записывайте ключевые события MCP, такие как инициализация, получение запросов/уведомлений, отправка ответов/ошибок.
    *   **Отслеживание потока сообщений:** Для отладки может быть полезно логировать (опционально и с учетом безопасности) сами JSON-RPC сообщения (или их части). Используйте разные уровни логирования (DEBUG, INFO, WARN, ERROR).
    *   **Мониторинг производительности:** Логируйте время выполнения ключевых операций для выявления узких мест.
    *   **Запись ошибок:** Подробно логируйте все ошибки, включая контекст запроса (без чувствительных данных), который привел к ошибке.

*   **Диагностика (Diagnostics):**
    *   **Реализация проверок состояния (Health Checks):** Предоставьте эндпоинт или MCP-метод для проверки текущего состояния сервера (например, `server/health`).
    *   **Мониторинг состояния соединения:** Отслеживайте активные соединения, их длительность, возможные проблемы с транспортом.
    *   **Отслеживание использования ресурсов:** Интегрируйте мониторинг использования системных ресурсов (ЦП, память) вашим MCP-сервером.

*   **Тестирование (Testing):**
    *   **Тестирование различных транспортов:** Если ваш сервер поддерживает несколько транспортов, убедитесь, что каждый из них протестирован.
    *   **Проверка обработки ошибок:** Создавайте тесты, которые симулируют различные ошибочные ситуации и проверяют корректность ответов сервера.
    *   **Проверка пограничных случаев:** Тестируйте поведение сервера с некорректными, неполными или неожиданными данными в запросах.
    *   **Нагрузочное тестирование серверов:** Проводите нагрузочное тестирование, чтобы понять, как сервер ведет себя под высокой нагрузкой и определить его пределы производительности.

Применение этих практик поможет создать более надежные, безопасные и удобные в поддержке MCP-серверы.

## 9. Заключение

Model Context Protocol (MCP) представляет собой значительный шаг вперед на пути к стандартизации и упрощению интеграции систем искусственного интеллекта с внешним миром данных и инструментов. Предоставляя общий, четко определенный язык для взаимодействия, MCP позволяет разработчикам сосредоточиться на создании инновационных ИИ-приложений, вместо того чтобы тратить время на разработку и поддержку многочисленных частных интеграций.

Рассмотренные в этой документации аспекты — от базовой архитектуры и типов сообщений до жизненного цикла соединения, обработки ошибок и примеров реализации — закладывают основу для понимания и эффективного использования протокола. Следование лучшим практикам и уделение должного внимания вопросам безопасности обеспечат создание надежных и защищенных MCP-серверов.

MCP — это развивающийся стандарт, и мы призываем вас ознакомиться с **официальной документацией** и принять участие в сообществе для получения самой актуальной информации, изучения SDK и готовых интеграций, а также для внесения своего вклада в развитие протокола:

*   **Официальный сайт MCP:** [https://modelcontextprotocol.io/](https://modelcontextprotocol.io/)
*   **Репозиторий на GitHub:** [https://github.com/modelcontextprotocol](https://github.com/modelcontextprotocol)

Надеемся, что данное руководство послужит полезным ресурсом для разработки ваших MCP-серверов.
