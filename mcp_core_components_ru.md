## 3. Основные компоненты MCP-сервера

MCP-сервер (и в равной степени MCP-клиент) для своей работы опирается на два фундаментальных уровня: протокольный и транспортный. Эти уровни разделяют ответственность за логику обмена сообщениями и фактическую передачу данных.

### 3.1 Протокольный уровень (Protocol Layer)

**Роль:** Протокольный уровень является "мозгом" MCP. Он отвечает за:
*   **Фрейминг сообщений (Message Framing):** Определение структуры и границ каждого сообщения в соответствии со стандартом JSON-RPC 2.0.
*   **Связывание запросов и ответов (Request/Response Linking):** Гарантирует, что каждый ответ или ошибка корректно сопоставляется с исходным запросом с помощью уникальных идентификаторов (`id`).
*   **Высокоуровневые шаблоны коммуникации (High-Level Communication Patterns):** Управляет логикой инициализации соединения, обработкой запросов, ответов, уведомлений и процедурой завершения соединения.

**Обработка входящих сообщений:** Когда сообщение поступает с транспортного уровня, протокольный уровень анализирует его. Если это запрос, он направляется соответствующему обработчику (handler), зарегистрированному для данного типа запроса (определяемого полем `method`). Если это уведомление, оно также передается соответствующему обработчику уведомлений. Если это ответ, протокольный уровень связывает его с ожидающим запросом.

**SDK и ключевые абстракции:** Для упрощения разработки приложений, работающих по MCP, предоставляются SDK (Software Development Kits – Наборы для Разработки ПО). Эти SDK предлагают высокоуровневые абстракции, скрывающие детали реализации протокола. Ключевые классы/интерфейсы обычно включают:

*   `Protocol` (или `Connection`, `Session`): Объект, инкапсулирующий состояние и логику всего MCP-соединения. Например, в Python SDK это может быть класс `Session`.
*   `Client`: Представляет клиентскую сторону соединения, предоставляя методы для отправки запросов и уведомлений.
*   `Server`: Представляет серверную сторону, предоставляя механизмы для регистрации обработчиков запросов и уведомлений.

Примеры обобщенных сигнатур методов, которые могут предоставляться SDK (точные имена и параметры зависят от конкретного языка и реализации):

*   Для сервера:
    *   `setRequestHandler(methodName: string, handler: (params: any) => Promise<any> | any)`: Регистрация обработчика для запросов с указанным `methodName`.
    *   `setNotificationHandler(methodName: string, handler: (params: any) => void)`: Регистрация обработчика для уведомлений.
*   Для клиента (или общего объекта `Session`):
    *   `sendRequest(methodName: string, params?: any): Promise<any>`: Отправка запроса и возврат Promise, который разрешится результатом или ошибкой.
    *   `sendNotification(methodName: string, params?: any): void`: Отправка уведомления.

Эти абстракции позволяют разработчикам сосредоточиться на бизнес-логике своих приложений, а не на низкоуровневых деталях протокола.

### 3.2 Транспортный уровень (Transport Layer)

**Роль:** Транспортный уровень отвечает за фактическую двунаправленную передачу байтов (сериализованных сообщений) между MCP-клиентом и MCP-сервером. Он обеспечивает нижележащий канал связи.

**JSON-RPC 2.0 через все транспорты:** Независимо от выбранного транспортного механизма, все сообщения MCP кодируются с использованием **JSON-RPC 2.0**. Это означает, что данные, передаваемые по транспортному каналу, представляют собой строки в формате JSON, структурированные согласно спецификации JSON-RPC 2.0. Подробную информацию о спецификации можно найти здесь: [https://www.jsonrpc.org/specification](https://www.jsonrpc.org/specification).

**Поддерживаемые транспортные механизмы:**

MCP поддерживает несколько транспортных механизмов, чтобы обеспечить гибкость в различных сценариях развертывания:

1.  **Stdio транспорт (Standard Input/Output Transport):**
    *   **Описание:** Использует стандартные потоки ввода (`stdin`) и вывода (`stdout`) процесса для обмена сообщениями. Клиент пишет JSON-RPC сообщения в `stdin` серверного процесса, а сервер пишет свои JSON-RPC сообщения в свой `stdout`, откуда их читает клиент.
    *   **Применение:** Идеально подходит для локального взаимодействия процессов, например, когда хост-приложение (например, IDE) запускает MCP-сервер как дочерний процесс на той же машине.
    *   **Преимущества:** Простота настройки для локальных сценариев, отсутствие необходимости в сетевой конфигурации, низкие задержки.

2.  **HTTP с SSE транспортом (HTTP with Server-Sent Events Transport):**
    *   **Описание:** Этот гибридный транспорт использует:
        *   **HTTP POST запросы:** для сообщений, идущих от клиента к серверу. Каждое JSON-RPC сообщение (запрос или уведомление) отправляется как тело HTTP POST запроса.
        *   **Server-Sent Events (SSE):** для сообщений, идущих от сервера к клиенту. SSE — это стандарт W3C, который позволяет серверу асинхронно отправлять данные клиенту по одному долгоживущему HTTP-соединению. Это эффективно для передачи ответов и уведомлений от сервера.
    *   **Применение:** Подходит для удаленного взаимодействия (клиент и сервер на разных машинах) или в случаях, когда коммуникация должна проходить через стандартную веб-инфраструктуру (например, прокси-серверы, балансировщики нагрузки).
    *   **Преимущества:** Совместимость со стандартной веб-инфраструктурой, хорошая поддержка в браузерах и серверных технологиях, эффективная передача данных от сервера к клиенту в реальном времени.

**Выбор подходящего транспорта:**

*   Для **локальных серверов**, особенно тех, что управляются как дочерние процессы хост-приложения, **Stdio транспорт** является наиболее распространенным и рекомендуемым выбором из-за его простоты и эффективности.
*   Для **удаленных серверов** или когда требуется интеграция через стандартные веб-протоколы, **HTTP с SSE транспортом** предоставляет надежное и широко совместимое решение.

Выбор транспорта определяется архитектурными требованиями приложения, такими как местоположение клиента и сервера, требования к безопасности и существующая инфраструктура.
